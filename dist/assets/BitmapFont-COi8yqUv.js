import{E as U,d as C,v as z,T,f as H,c as L,C as M,R as A,e as j,I as G,g as R,h as q,i as W,l as J,j as _,w as Z,k as V}from"./index-BVpOR-g2.js";class $ extends U{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return C(z,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return C(z,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return C(z,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return C(z,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return C(z,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){var e;this.emit("destroy",this),this.removeAllListeners();for(const i in this.chars)(e=this.chars[i].texture)==null||e.destroy();this.chars=null,t&&(this.pages.forEach(i=>i.texture.destroy(!0)),this.pages=null)}}const Y=class X extends ${constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const e={...X.defaultOptions,...t};this._textureSize=e.textureSize,this._mipmap=e.mipmap;const i=e.style.clone();e.overrideFill&&(i._fill.color=16777215,i._fill.alpha=1,i._fill.texture=T.WHITE,i._fill.fill=null),this.applyFillAsTint=e.overrideFill;const s=i.fontSize;i.fontSize=this.baseMeasurementFontSize;const n=H(i);e.overrideSize?i._stroke&&(i._stroke.width*=this.baseRenderedFontSize/s):i.fontSize=this.baseRenderedFontSize=s,this._style=i,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,e.textureStyle&&(this._textureStyle=e.textureStyle instanceof L?e.textureStyle:new L(e.textureStyle)),this.fontMetrics=M.measureFont(n),this.lineHeight=i.lineHeight||this.fontMetrics.fontSize||i.fontSize}ensureCharacters(t){var F,p;const e=M.graphemeSegmenter(t).filter(c=>!this._currentChars.includes(c)).filter((c,f,g)=>g.indexOf(c)===f);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let i;this._currentPageIndex===-1?i=this._nextPage():i=this.pages[this._currentPageIndex];let{canvas:s,context:n}=i.canvasAndContext,a=i.texture.source;const r=this._style;let o=this._currentX,h=this._currentY,l=this._currentMaxCharHeight;const u=this.baseRenderedFontSize/this.baseMeasurementFontSize,m=this._padding*u;let S=!1;const y=s.width/this.resolution,w=s.height/this.resolution;for(let c=0;c<e.length;c++){const f=e[c],g=M.measureText(f,r,s,!1);g.lineHeight=g.height;const O=g.width*u,P=Math.ceil((r.fontStyle==="italic"?2:1)*O),b=g.height*u,x=P+m*2,B=b+m*2;if(S=!1,f!==`
`&&f!=="\r"&&f!=="	"&&f!==" "&&(S=!0,l=Math.ceil(Math.max(B,l))),o+x>y&&(h+=l,l=B,o=0,h+l>w)){a.update();const v=this._nextPage();s=v.canvasAndContext.canvas,n=v.canvasAndContext.context,a=v.texture.source,o=0,h=0,l=0}const D=O/u-(((F=r.dropShadow)==null?void 0:F.distance)??0)-(((p=r._stroke)==null?void 0:p.width)??0);if(this.chars[f]={id:f.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:D,kerning:{}},S){this._drawGlyph(n,g,o+m,h+m,u,r);const v=a.width*u,I=a.height*u,N=new A(o/v*a.width,h/I*a.height,x/v*a.width,B/I*a.height);this.chars[f].texture=new T({source:a,frame:N}),o+=Math.ceil(x)}}a.update(),this._currentX=o,this._currentY=h,this._currentMaxCharHeight=l,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return C(z,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const i=this._measureCache;for(let s=0;s<t.length;s++){const n=t[s];for(let a=0;a<this._currentChars.length;a++){const r=this._currentChars[a];let o=i[n];o||(o=i[n]=e.measureText(n).width);let h=i[r];h||(h=i[r]=e.measureText(r).width);let l=e.measureText(n+r).width,u=l-(o+h);u&&(this.chars[n].kerning[r]=u),l=e.measureText(n+r).width,u=l-(o+h),u&&(this.chars[r].kerning[n]=u)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=j.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const i=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),s=new T({source:new G({resource:e.canvas,resolution:i,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(s.source.style=this._textureStyle);const n={canvasAndContext:e,texture:s};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,i){e.fontSize=this.baseRenderedFontSize,t.scale(i,i),t.font=H(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const s=e._stroke,n=(s==null?void 0:s.width)??0;if(s&&(t.lineWidth=n,t.lineJoin=s.join,t.miterLimit=s.miterLimit,t.strokeStyle=R(s,t)),e._fill&&(t.fillStyle=R(e._fill,t)),e.dropShadow){const a=e.dropShadow,r=q.shared.setValue(a.color).toArray(),o=a.blur*i,h=a.distance*i;t.shadowColor=`rgba(${r[0]*255},${r[1]*255},${r[2]*255},${a.alpha})`,t.shadowBlur=o,t.shadowOffsetX=Math.cos(a.angle)*h,t.shadowOffsetY=Math.sin(a.angle)*h}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,i,s,n,a){const r=e.text,o=e.fontProperties,h=a._stroke,l=((h==null?void 0:h.width)??0)*n,u=i+l/2,m=s-l/2,S=o.descent*n,y=e.lineHeight*n;let w=!1;a.stroke&&l&&(w=!0,t.strokeText(r,u,m+y-S));const{shadowBlur:F,shadowOffsetX:p,shadowOffsetY:c}=t;a._fill&&(w&&(t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0),t.fillText(r,u,m+y-S)),w&&(t.shadowBlur=F,t.shadowOffsetX=p,t.shadowOffsetY=c)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:i}=this.pages[t];j.returnCanvasAndContext(e),i.destroy(!0)}this.pages=null}};Y.defaultOptions={textureSize:512,style:new W,mipmap:!0};let E=Y;function Q(d,t,e,i){const s={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};s.offsetY=e.baseLineOffset;let n=s.lines[0],a=null,r=!0;const o={width:0,start:0,index:0,positions:[],chars:[]},h=e.baseMeasurementFontSize/t.fontSize,l=t.letterSpacing*h,u=t.wordWrapWidth*h,m=t.lineHeight?t.lineHeight*h:e.lineHeight,S=t.wordWrap&&t.breakWords,y=p=>{const c=n.width;for(let f=0;f<o.index;f++){const g=p.positions[f];n.chars.push(p.chars[f]),n.charPositions.push(g+c)}n.width+=p.width,r=!1,o.width=0,o.index=0,o.chars.length=0},w=()=>{let p=n.chars.length-1;if(i){let c=n.chars[p];for(;c===" ";)n.width-=e.chars[c].xAdvance,c=n.chars[--p]}s.width=Math.max(s.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},r=!0,s.lines.push(n),s.height+=m},F=p=>p-l>u;for(let p=0;p<d.length+1;p++){let c;const f=p===d.length;f||(c=d[p]);const g=e.chars[c]||e.chars[" "];if(/(?:\s)/.test(c)||c==="\r"||c===`
`||f){if(!r&&t.wordWrap&&F(n.width+o.width)?(w(),y(o),f||n.charPositions.push(0)):(o.start=n.width,y(o),f||n.charPositions.push(0)),c==="\r"||c===`
`)w();else if(!f){const x=g.xAdvance+(g.kerning[a]||0)+l;n.width+=x,n.spaceWidth=x,n.spacesIndex.push(n.charPositions.length),n.chars.push(c)}}else{const b=g.kerning[a]||0,x=g.xAdvance+b+l;S&&F(n.width+o.width+x)&&(y(o),w()),o.positions[o.index++]=o.width+b,o.chars.push(c),o.width+=x}a=c}return w(),t.align==="center"?ee(s):t.align==="right"?te(s):t.align==="justify"&&se(s),s}function ee(d){for(let t=0;t<d.lines.length;t++){const e=d.lines[t],i=d.width/2-e.width/2;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=i}}function te(d){for(let t=0;t<d.lines.length;t++){const e=d.lines[t],i=d.width-e.width;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=i}}function se(d){const t=d.width;for(let e=0;e<d.lines.length;e++){const i=d.lines[e];let s=0,n=i.spacesIndex[s++],a=0;const r=i.spacesIndex.length,h=(t-i.width)/r;for(let l=0;l<i.charPositions.length;l++)l===n&&(n=i.spacesIndex[s++],a+=h),i.charPositions[l]+=a}}function ie(d){if(d==="")return[];typeof d=="string"&&(d=[d]);const t=[];for(let e=0,i=d.length;e<i;e++){const s=d[e];if(Array.isArray(s)){if(s.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);if(s[0].length===0||s[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=s[0].charCodeAt(0),a=s[1].charCodeAt(0);if(a<n)throw new Error("[BitmapFont]: Invalid character range.");for(let r=n,o=a;r<=o;r++)t.push(String.fromCharCode(r))}else t.push(...Array.from(s))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}let k=0;class ne{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=J(1e3)}getFont(t,e){var a;let i=`${e.fontFamily}-bitmap`,s=!0;if(e._fill.fill&&!e._stroke?(i+=e._fill.fill.styleKey,s=!1):(e._stroke||e.dropShadow)&&(i=`${e.styleKey}-bitmap`,s=!1),!_.has(i)){const r=Object.create(e);r._lineHeight=0;const o=new E({style:r,overrideFill:s,overrideSize:!0,...this.defaultOptions});k++,k>50&&Z("BitmapText",`You have dynamically created ${k} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),o.once("destroy",()=>{k--,_.remove(i)}),_.set(i,o)}const n=_.get(i);return(a=n.ensureCharacters)==null||a.call(n,t),n}getLayout(t,e,i=!0){const s=this.getFont(t,e),n=`${t}-${e.styleKey}-${i}`;if(this.measureCache.has(n))return this.measureCache.get(n);const a=M.graphemeSegmenter(t),r=Q(a,e,s,i);return this.measureCache.set(n,r),r}measureText(t,e,i=!0){return this.getLayout(t,e,i)}install(...t){var h,l,u,m;let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:(h=t[2])==null?void 0:h.chars,resolution:(l=t[2])==null?void 0:l.resolution,padding:(u=t[2])==null?void 0:u.padding,skipKerning:(m=t[2])==null?void 0:m.skipKerning},C(z,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const i=e==null?void 0:e.name;if(!i)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const s=e.style,n=s instanceof W?s:new W(s),a=e.dynamicFill??this._canUseTintForStyle(n),r=new E({style:n,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1,textureStyle:e.textureStyle}),o=ie(e.chars);return r.ensureCharacters(o.join("")),_.set(`${i}-bitmap`,r),r.once("destroy",()=>_.remove(`${i}-bitmap`)),r}uninstall(t){const e=`${t}-bitmap`,i=_.get(e);i&&i.destroy()}_canUseTintForStyle(t){return!t._stroke&&(!t.dropShadow||t.dropShadow.color===0)&&!t._fill.fill&&t._fill.color===16777215}}const K=new ne;class re extends ${constructor(t,e){super();const{textures:i,data:s}=t;Object.keys(s.pages).forEach(n=>{const a=s.pages[parseInt(n,10)],r=i[a.id];this.pages.push({texture:r})}),Object.keys(s.chars).forEach(n=>{const a=s.chars[n],{frame:r,source:o,rotate:h}=i[a.page],l=V.transformRectCoords(a,r,h,new A),u=new T({frame:l,orig:new A(0,0,a.width,a.height),source:o,rotate:h});this.chars[n]={id:n.codePointAt(0),xOffset:a.xOffset,yOffset:a.yOffset,xAdvance:a.xAdvance,kerning:a.kerning??{},texture:u}}),this.baseRenderedFontSize=s.fontSize,this.baseMeasurementFontSize=s.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:s.fontSize},this.baseLineOffset=s.baseLineOffset,this.lineHeight=s.lineHeight,this.fontFamily=s.fontFamily,this.distanceField=s.distanceField??{type:"none",range:0},this.url=e}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{texture:e}=this.pages[t];e.destroy(!0)}this.pages=null}static install(t){K.install(t)}static uninstall(t){K.uninstall(t)}}export{re as BitmapFont};
